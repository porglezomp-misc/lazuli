(struct cons car cdr)
(let! car cons/car)
(let! cdr cons/cdr)

(let! nil ())
(defn (nil? xs)
  (== xs nil))

(defn (list/map f xs)
  (if xs
    (cons (f (car xs))
          (list/map f (cdr xs)))))

(defn (list/filter p xs)
  (if xs
      (if (p (car xs))
          (cons (car xs)
                (filter p (cdr xs)))
          (cdr xs))))

(defn (list/foldl f x xs)
  (loop ((x x) (xs xs))
    (if (nil? xs) (break x))
    (continue (f x (car xs)) (cdr xs))))

(defn (list/length xs)
  (if (nil? xs)
      0
      (+ 1 (list/length (cdr xs)))))

(defn (list/reverse xs)
  (loop ((accum nil) (xs xs))
    (if (nil? xs) (break accum))
    (continue (cons (car xs) accum) (cdr xs))))

(defn (list/nth n xs)
  (loop ((n n) (xs xs))
    (if (nil? xs) (break nil))
    (if (<= n 0) (break (car xs)))
    (continue (- n 1) (cdr xs))))

(defn (list/set-nth n xs val)
  (if xs
      (if (<= n 0)
          (cons val (cdr xs))
          (cons (car xs) (list/set-nth (- n 1) (cdr xs) val)))))

(defn (list/update-nth n xs f)
  (if xs
      (if (<= n 0)
          (cons (f (car xs)) (cdr xs))
          (cons (car xs) (list/update-nth (- n 1) (cdr xs) f)))))

(let! not nil?)
