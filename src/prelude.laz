(struct cons car cdr)
(let! car cons/car)
(let! cdr cons/cdr)

(let! nil ())
(defn (nil? xs)
  (== xs nil))

(defn (list/map f xs)
  (let! result (hole))
  (loop ((xs xs) (spot result))
    (if (nil? xs) (break (hole/fill spot nil)))
    (let! new-spot (hole))
    (hole/fill spot (cons (f (car xs)) new-spot))
    (continue (cdr xs) new-spot))
  result)

(defn (list/filter p xs)
  (let! result (hole))
  (loop ((xs xs) (spot result))
    (if (nil? xs) (break (hole/fill spot nil)))
    (if (not (p (car xs))) (continue (cdr xs) spot))
    (let! new-spot (hole))
    (hole/fill spot (cons (car xs) new-spot))
    (continue (cdr xs) new-spot))
  result)

(defn (list/foldl f x xs)
  (loop ((x x) (xs xs))
    (if (nil? xs) (break x))
    (continue (f x (car xs)) (cdr xs))))

(defn (list/length xs)
  (loop ((count 0) (xs xs))
    (if (nil? xs) (break count))
    (continue (+ count 1) (cdr xs))))

(defn (list/reverse xs)
  (loop ((accum nil) (xs xs))
    (if (nil? xs) (break accum))
    (continue (cons (car xs) accum) (cdr xs))))

(defn (list/nth n xs)
  (loop ((n n) (xs xs))
    (if (nil? xs) (break nil))
    (if (<= n 0) (break (car xs)))
    (continue (- n 1) (cdr xs))))

(defn (list/set-nth n xs val)
  (let! result (hole))
  (loop ((n n) (xs xs) (spot result))
    (if (nil? xs) (break (hole/fill spot nil)))
    (if (<= n 0) (break (hole/fill spot (cons val (cdr xs)))))
    (let! new-spot (hole))
    (hole/fill spot (cons (car xs) new-spot))
    (continue (- n 1) (cdr xs) new-spot))
  result)

(defn (list/update-nth n xs f)
  (let! result (hole))
  (loop ((n n) (xs xs) (spot result))
    (if (nil? xs) (break (hole/fill spot nil)))
    (if (<= n 0)
      (break (hole/fill spot
               (cons (f (car xs)) (cdr xs)))))
    (let! new-spot (hole))
    (hole/fill spot (cons (car xs) new-spot))
    (continue (- n 1) (cdr xs) new-spot))
  result)

(let! not nil?)
